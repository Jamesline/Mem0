from typing import Any, Callable, Dict, List

try:
    from qdrant_client import QdrantClient
    from qdrant_client.models import Distance, VectorParams
    from qdrant_client.http.models import Batch
except ImportError:
    raise ImportError("Qdrant requires extra dependencies. Install with `pip install embedchain[qdrant]`") from None

from embedchain.config import QdrantDBConfig
from embedchain.models.VectorDimensions import VectorDimensions
from embedchain.vectordb.base_vector_db import BaseVectorDB


class QdrantDB(BaseVectorDB):
    def __init__(
        self,
        qdrant_config: QdrantDBConfig = None,
        embedding_fn: Callable[[list[str]], list[str]] = None,
        vector_dim: VectorDimensions = None,
        collection_name: str = None,
    ):
        """
        Qdrant as vector database
        :param es_config. Qdrant database config to be used for connection
        :param embedding_fn: Function to generate embedding vectors.
        :param vector_dim: Vector dimension generated by embedding fn
        :param collection_name: Optional. Collection name for the database.
        """
        if not hasattr(embedding_fn, "__call__"):
            raise ValueError("Embedding function is not a function")
        if qdrant_config is None:
            raise ValueError("QdrantDBConfig is required")
        if vector_dim is None:
            raise ValueError("Vector Dimension is required to refer correct index and mapping")
        if collection_name is None:
            raise ValueError("collection name is required. It cannot be empty")
        self.embedding_fn = embedding_fn
        self.client = QdrantClient(url=qdrant_config.URL)
        self.vector_dim = vector_dim
        self.collection = f"{collection_name}_{self.vector_dim}"

        print("Creating collection", self.collection)
        self.client.recreate_collection(
            collection_name=self.collection,
            vectors_config=VectorParams(size=self.vector_dim, distance=Distance.COSINE),
        )
        super().__init__()

    def _get_or_create_db(self):
        return self.client

    def _get_or_create_collection(self, name):
        """Note: nothing to return here. Discuss later"""

    def get(self, ids: List[str], where: Dict[str, any]) -> List[str]:
        """
        Get existing doc ids present in vector database
        :param ids: list of doc ids to check for existance
        :param where: Optional. to filter data
        """
        response = self.client.retrieve(collection_name=self.collection, ids=ids)
        ids = [doc["id"] for doc in response["result"]]
        return set(ids)

    def add(self, documents: List[str], metadatas: List[object], ids: List[str]) -> Any:
        """
        add data in vector database
        :param documents: list of texts to add
        :param metadatas: list of metadata associated with docs
        :param ids: ids of docs
        """

        embeddings = self.embedding_fn(documents)

        docs = [
            {
                "id": id,
                "text": document,
                "metadata": metadata,
            }
            for id, document, metadata in zip(ids, documents, metadatas)
        ]
        self.client.upsert(
            collection_name=self.collection,
            points=Batch(
                ids=ids,
                payloads=docs,
                vectors=[embeddings],
            ),
        )

    def query(self, input_query: List[str], n_results: int, where: Dict[str, any]) -> List[str]:
        """
        query contents from vector data base based on vector similarity
        :param input_query: list of query string
        :param n_results: no of similar documents to fetch from database
        :param where: Optional. to filter data
        """
        input_query_vector = self.embedding_fn(input_query)
        query_vector = input_query_vector[0]

        response = self.client.search(
            collection_name=self.collection,
            query_vector=query_vector,
            limit=n_results,
        )
        return [doc["payload"]["text"] for doc in response["result"]]

    def count(self) -> int:
        response = self.client.get_collection(collection_name=self.collection)
        return response["points_count"]

    def reset(self):
        self.client.delete_collection(collection_name=self.collection)
